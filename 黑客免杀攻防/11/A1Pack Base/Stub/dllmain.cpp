/************************************************************************
*
* ----------------
*  dllmain.cpp
* ----------------
* 功能描述：
*     此文件中包含有Stub的入口函数与开始函数，是用于引导整个Stub执行的核心
* 部分，此部分代码可以被看做为整个壳的功能目录，因为壳会做的所有事都会在此
* 有所体现。
*     壳的大体执行流程为：入口函数 -> 开始函数 -> JMP到原OEP -> 退出。
* 
* ----------
*  版本信息
* ----------
* V1.0.0 Base 2012-07-20 (AI-32)
* 
* ----------
*  版权信息
* ----------
*     此源码为任晓珲(网名:A1Pass)创作，任晓珲(网名:A1Pass)对此享有完全著
* 作权。任何人在未经授权的情况下不得使用此源码，任何人取得使用权后不得删除
* 或更改此版权信息。所有由此代码衍生出来的产品、代码、文件、多媒体，都应注
* 明其应用了本源码中的全部或部分技术信息。
*                      CM. Ren Xiaohui(A1Pass), 2012. All rights reserved.
* 
* ----------
*  提示信息
* ----------
*     此代码隶属于黑客反病毒组织支持的开源项目“A1Pack”，此项目由A1Pass为
* 撰写《黑客免杀攻防》而创立，这个项目的核心思想是创建一个用最简单、最容易
* 维护的代码实现一个功能全面，兼容性良好的加壳产品。
*     此项目共有“A1Pack Base”、“A1Pack Intermediate”与“A1Pack Advanced”
* 三种版本，其中“A1Pack Base”的全部代码与“A1Pack Intermediate”的部分代码
* 将分别以全部开源与半开源的方式用于《黑客免杀攻防》，“A1Pack Advanced”则
* 属于软件项目，不开放源代码。
*     如果您想更轻松更快速的理解本项目的中心逻辑及核心思想，建议您购买
* 《黑客免杀攻防》配合阅读，书中详细的讲解了此项目的核心思想与一些代码的逻辑
* 细节。
*
* ----------
*  免责声明
* ----------
*     此代码虽然经过了详细的测试与分析，但作者本人并不为由于使用此代码对
* 使用者造成的任何直接或间接损失负责。
*     使用者应该具备有一定的公民素质与技术判别能力，作者对于其他人使用此
* 代码进行的任何违法行为不负任何责任；作者对其他人由于技术能力不足而无法
* 正确使用此代码产生的任何后果不负任何责任。
* 
************************************************************************/
#include "stdafx.h"
#include "Stub.h"

#pragma comment(linker, "/entry:\"StubEntryPoint\"") // 指定程序入口函数为StubEntryPoint()
#pragma comment(linker, "/merge:.data=.text")        // 将.data合并到.text
#pragma comment(linker, "/merge:.rdata=.text")       // 将.rdata合并到.text
#pragma comment(linker, "/section:.text,RWE")        // 将.text段的属性设置为可读、可写、可执行





/*********************************************************************
* Stub开始函数
*     此函数是Stub所有功能函数的集中调用者，它负责按照预定的逻辑顺序调
* 用Stub的各种功能，最终完成对宿主文件的操作。
*
* 参数：无
* 
* 返回值：无
*********************************************************************/
void start()
{
	// 1. 初始化所有API
	if ( !InitializationAPI() )  return;


	// 2. 解密宿主程序
	Decrypt();


	// 3. 询问是否执行解密后的程序
	if ( g_stcParam.bShowMessage )
	{
		int nRet = g_funMessageBox(NULL,L"解密完成，是否运行原程序？",L"解密完成",MB_OKCANCEL);
		if (IDCANCEL == nRet)  return;
	}


	// 4. 跳转到OEP
	__asm jmp g_stcParam.dwOEP;
}





/*********************************************************************
* Stub部分的入口函数
*     此函数是Stub的入口，也是加壳后程序的入口处，之所以采取裸函数的
* 形式就是为了方便对函数的细节进行控制（包括抑制编译器生成引导代码），
*     这个函数只做了两件事，一个是调用我们的开始函数“start()”来执行
* 壳的若干功能，另一个就是在执行完start()后调用ExitProcess结束掉本进
* 程。
*     此函数的这种形式是经过A1Pass多次测试后总结出的最佳方案，可以最
* 大化的保证加壳后程序的稳定性，以及整个壳的兼容性。
*
* 参数：无
* 
* 返回值：无
*********************************************************************/
void __declspec(naked) StubEntryPoint()
{
	__asm sub esp,0x50;        // 抬高栈顶，提高兼容性
	start();                   // 执行壳的主体部分
	__asm add esp,0x50;        // 平衡堆栈

	// 主动调用ExitProcess函数退出进程可以解决一些兼容性问题
	if ( g_funExitProcess )
	{
		g_funExitProcess(0);
	}

	__asm retn;
}
